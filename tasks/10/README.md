# Ретроспекция, част 2

Това е втората ретроспективна задача и последното домашно за курса. Трябва да решите отново пета, шеста, седма и осма задача. Както и в [първата част на ретроспекцията](/tasks/9), целта е да постигнете кратки и ясни решения, които да включват всичко, което сте научили до момента. Прочетете [условието на девета задача](/tasks/9), за по-детайлно обяснение на целите и мотивацията на задачата.

Отново, това е много добър шанс да запълните някой пропуск, да затвърдите знание, или да пробвате друга гледна точка.

## Форма на предаване

Форматът на предаване е същият като на предната задача, като и за тази е необходимо да напишете 20 неща, научени докато пишете или рефакторирате решенията си на пета, шеста, седма и осма задача.

Отново трябва да направите fork на [нашето хранилище за втората част на ретроспекцията](https://github.com/fmi/ruby-retrospective-2015-2), да си клонирате копието с `git clone ...` и да промените <code>.rb</code> файловете за всяко от решенията. Напомняме, че първият ви commit трябва да бъде със старите ви решения във вида, в който сте ги предали в сайта за последен път. Ако не сте предали решение за дадена задача, оставяте файла на решението празен.

Дефиницията на стиловите ограничения е във [файла `skeptic.yml`](https://github.com/fmi/ruby-retrospective-2015-2/blob/master/skeptic.yml). Проверката дали решенията ви минават тестовете и ограниченията става с:

    $ bundle exec rake check

Може да проверите същото само за една конкретна задача така:

    $ bundle exec rake tasks:06

В тази команда, `06` е номерът на задачата, която искате да проверите.

Научените уроци от рефакторинга на пета до осма задача   се предават в сайта на курса, с добре познатия ви формуляр, в същия формат както при девета задача – константа `REPOSITORY` и списък от научени неща в коментари. Например:

    REPOSITORY = 'http://github.com/mitio/ruby-retrospective-2015-2'

    # Двадесет неща, които научих.
    #
    # 1. Монадите в Haskell са много широка абстракция. Приложими са на много места,
    #    но това ги прави трудни за научаване. Любимият ми пример е Maybe монадата,
    #    в която верига от операции връща Nothing, ако връзка от веригата върне
    #    Nothing.
    # 2. case клас (в Scala) е по-подходящ за промоция, от стандартен такъв.
    # 3. Проверката за възраст може да се реализира по-добре с полиморфизъм, отколкото
    #    с case или if.

`REPOSITORY` трябва да съдържа HTTP URL-а до вашия fork на хранилището за това второ ретроспективно домашно.

**Съвети и бележки**

Същите са като за първата част на ретроспекцията:

- Не променяйте други файлове в хранилището, освен вашите решения. Всички други промени ще бъдат игнорирани.
- Уверете се, че при предаване на решенито през формуляра на сайта, имате дефинирана въпросната константа, че стойността ѝ е низ и че не е коментирана.
- Не забравяйте да push-нете последните промени, които сте направили, в GitHub хранилището си. Промени, качени в GitHub след крайния срок на задачата няма да се зачитат.

## Оценяване и други бележки

Останалото е идентично с описанието на [първата част на ретроспекцията](/tasks/9).
